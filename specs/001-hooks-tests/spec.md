# Feature Specification: 핵심 Hooks 단위 테스트 작성

**Feature Branch**: `001-hooks-tests`
**Created**: 2025-11-06
**Status**: Draft
**Input**: User description: "Phase 2-3: 핵심 Hooks 단위 테스트 작성 (useNotifications, useScheduleData, useApplicantActions)"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - 지원자 관리 Hook 테스트 검증 (Priority: P1)

개발자가 지원자 관리 기능(`useApplicantActions`)의 핵심 비즈니스 로직을 테스트 코드로 검증하여, 지원자 승인/거부/일괄 처리 등의 작업이 모든 상황에서 정확하게 동작함을 보장한다.

**Why this priority**: 지원자 관리는 시스템의 핵심 비즈니스 로직이며, 803줄의 복잡한 코드로 구성되어 있어 가장 높은 테스트 커버리지가 필요합니다. 잘못된 동작은 직접적인 비즈니스 손실로 이어질 수 있습니다.

**Independent Test**: 지원자 승인 기능만 구현하고 테스트하면, "지원자를 승인하면 상태가 'approved'로 변경되고 알림이 발송된다"는 독립적인 가치를 제공할 수 있습니다.

**Acceptance Scenarios**:

1. **Given** 대기 중인 지원자가 있을 때, **When** 개발자가 지원자 승인 로직을 테스트하면, **Then** 테스트가 지원자 상태가 'approved'로 변경되고 Firebase가 올바르게 업데이트됨을 검증한다
2. **Given** 여러 지원자를 선택했을 때, **When** 개발자가 일괄 승인 로직을 테스트하면, **Then** 테스트가 모든 지원자의 상태가 동시에 업데이트되고 각각의 알림이 발송됨을 검증한다
3. **Given** Firebase 업데이트가 실패할 때, **When** 개발자가 에러 복구 로직을 테스트하면, **Then** 테스트가 적절한 에러 메시지가 표시되고 데이터 일관성이 유지됨을 검증한다
4. **Given** 지원자 정보가 불완전할 때, **When** 개발자가 유효성 검증 로직을 테스트하면, **Then** 테스트가 작업이 차단되고 명확한 검증 오류 메시지가 제공됨을 검증한다
5. **Given** 동시에 여러 작업이 실행될 때, **When** 개발자가 경쟁 조건을 테스트하면, **Then** 테스트가 모든 작업이 순차적으로 처리되고 데이터 충돌이 발생하지 않음을 검증한다

---

### User Story 2 - 급여 계산 Hook 테스트 검증 (Priority: P2)

개발자가 스케줄 데이터 및 급여 계산 Hook(`useScheduleData`)의 계산 로직을 테스트 코드로 검증하여, 급여, 야간수당, 휴일수당, 연장수당 등이 정확하게 계산됨을 보장한다.

**Why this priority**: 급여 계산은 재무적 정확성이 요구되는 핵심 기능이며, 323줄의 복잡한 계산 로직을 포함합니다. 계산 오류는 법적 문제와 직원 신뢰 손실로 이어질 수 있습니다.

**Independent Test**: 기본 급여 계산만 구현하고 테스트하면, "근무 시간에 따라 기본 급여가 정확히 계산된다"는 독립적인 가치를 제공할 수 있습니다.

**Acceptance Scenarios**:

1. **Given** 근무 기록이 있을 때, **When** 개발자가 기본 급여 계산 로직을 테스트하면, **Then** 테스트가 근무 시간과 시급에 따라 급여가 정확히 계산됨을 검증한다
2. **Given** 야간 근무 기록이 있을 때, **When** 개발자가 야간수당 계산 로직을 테스트하면, **Then** 테스트가 야간 시간대(22:00-06:00)에 대해 추가 수당이 정확히 계산됨을 검증한다
3. **Given** 휴일 근무 기록이 있을 때, **When** 개발자가 휴일수당 계산 로직을 테스트하면, **Then** 테스트가 휴일에 대해 1.5배 수당이 정확히 계산됨을 검증한다
4. **Given** 캐싱된 데이터가 있을 때, **When** 개발자가 캐싱 동작을 테스트하면, **Then** 테스트가 불필요한 재계산 없이 캐시된 값이 반환됨을 검증한다
5. **Given** 잘못된 근무 데이터가 입력될 때, **When** 개발자가 데이터 검증 로직을 테스트하면, **Then** 테스트가 계산이 중단되고 명확한 오류 메시지가 제공됨을 검증한다

---

### User Story 3 - 알림 시스템 Hook 테스트 검증 (Priority: P3)

개발자가 알림 시스템 Hook(`useNotifications`)의 실시간 구독 및 알림 관리 로직을 테스트 코드로 검증하여, 사용자가 모든 중요한 알림을 적시에 받을 수 있음을 보장한다.

**Why this priority**: 알림 시스템은 사용자 경험에 중요하지만, 다른 두 Hook에 비해 상대적으로 독립적이며 비즈니스 영향도가 낮습니다. 단, 실시간 구독의 특성상 테스트가 복잡할 수 있습니다.

**Independent Test**: 알림 조회 기능만 구현하고 테스트하면, "사용자의 알림 목록이 실시간으로 업데이트된다"는 독립적인 가치를 제공할 수 있습니다.

**Acceptance Scenarios**:

1. **Given** Firestore에 새 알림이 추가될 때, **When** 개발자가 실시간 구독 로직을 테스트하면, **Then** 테스트가 Hook이 즉시 새 알림을 감지하고 상태를 업데이트함을 검증한다
2. **Given** 읽지 않은 알림이 있을 때, **When** 개발자가 알림 필터링 로직을 테스트하면, **Then** 테스트가 읽음/안읽음 상태에 따라 알림이 정확히 필터링됨을 검증한다
3. **Given** 사용자가 알림을 읽음 처리할 때, **When** 개발자가 읽음 처리 로직을 테스트하면, **Then** 테스트가 Firestore가 업데이트되고 UI 상태가 동기화됨을 검증한다
4. **Given** 사용자가 알림을 삭제할 때, **When** 개발자가 삭제 로직을 테스트하면, **Then** 테스트가 Firestore에서 알림이 제거되고 Hook 상태에서도 제거됨을 검증한다
5. **Given** Firestore 연결이 실패할 때, **When** 개발자가 에러 핸들링 로직을 테스트하면, **Then** 테스트가 적절한 에러 상태가 설정되고 사용자에게 피드백이 제공됨을 검증한다

---

### Edge Cases

- 각 Hook이 마운트 해제될 때 Firestore 리스너가 정리되지 않으면 메모리 누수가 발생하는가?
- 매우 큰 데이터셋(1000+ 알림, 100+ 지원자)을 처리할 때 Hook이 성능 저하 없이 동작하는가?
- Hook이 동시에 여러 번 호출될 때 상태 충돌이 발생하는가?
- Firebase Mock이 실제 Firestore의 모든 동작(실시간 구독, 트랜잭션 등)을 정확히 시뮬레이션하는가?
- 네트워크가 불안정하거나 끊어질 때 Hook이 적절히 재시도하거나 에러를 처리하는가?
- 타임아웃이 설정된 비동기 작업이 제한 시간을 초과할 때 테스트가 올바르게 실패하는가?
- 권한이 없는 사용자가 Hook을 사용할 때 적절한 접근 제어가 작동하는가?

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: 테스트 시스템은 `useNotifications`, `useScheduleData`, `useApplicantActions` 세 개의 Hook에 대한 단위 테스트를 포함해야 한다
- **FR-002**: 각 Hook의 테스트 커버리지는 최소 70% 이상을 달성해야 한다
- **FR-003**: 테스트는 모든 핵심 비즈니스 로직(지원자 승인/거부, 급여 계산, 알림 필터링 등)을 검증해야 한다
- **FR-004**: 테스트는 각 Hook당 최소 5개 이상의 에러 케이스를 커버해야 한다
- **FR-005**: 테스트는 모든 비동기 작업(Firestore 구독, Firebase 업데이트 등)을 정확히 검증해야 한다
- **FR-006**: 테스트는 `@testing-library/react-hooks`의 `renderHook` 패턴을 사용해야 한다
- **FR-007**: 테스트는 Firebase(Firestore, Functions)를 Mock으로 대체하여 독립적으로 실행되어야 한다
- **FR-008**: 테스트는 `waitFor`와 `act`를 올바르게 사용하여 비동기 상태 업데이트를 처리해야 한다
- **FR-009**: 테스트는 타임아웃을 적절히 설정하여 무한 대기를 방지해야 한다
- **FR-010**: 각 Hook의 테스트는 독립적으로 실행 가능해야 하며, 다른 테스트에 의존하지 않아야 한다
- **FR-011**: 테스트 실행은 전체 8초 이내에 완료되어야 한다
- **FR-012**: 테스트는 프로덕션 코드를 최소한으로 수정하며, Hook의 인터페이스를 변경하지 않아야 한다
- **FR-013**: 테스트는 성능 저하를 초래하지 않아야 한다

### Key Entities

- **Test Suite**: 각 Hook에 대한 테스트 파일 모음 (useNotifications.test.ts, useScheduleData.test.ts, useApplicantActions.test.ts)
- **Mock Data**: 테스트에 사용되는 시뮬레이션 데이터 (알림 객체, 근무 기록, 지원자 정보)
- **Firebase Mock**: Firestore와 Functions를 시뮬레이션하는 Mock 객체
- **Test Scenario**: 각 테스트 케이스가 검증하는 특정 상황 (정상 동작, 에러 케이스, 엣지 케이스)
- **Coverage Report**: 각 Hook의 코드 커버리지를 보여주는 리포트 (라인, 브랜치, 함수, 문장 커버리지)

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 각 Hook의 테스트 커버리지가 70% 이상 달성된다 (라인 커버리지 기준)
- **SC-002**: 모든 테스트가 `npm run test` 명령어로 성공적으로 통과한다
- **SC-003**: 전체 테스트 실행 시간이 8초 이내로 완료된다
- **SC-004**: 각 Hook당 최소 5개 이상의 에러 케이스가 테스트로 커버된다
- **SC-005**: 모든 비동기 로직(Firestore 구독, Firebase 업데이트)이 테스트로 검증된다
- **SC-006**: 테스트 추가 후 프로덕션 코드의 성능이 기존 대비 저하되지 않는다 (±5% 이내)
- **SC-007**: 각 테스트 파일이 독립적으로 실행 가능하며, 병렬 실행 시 충돌이 발생하지 않는다
- **SC-008**: `npm run test:coverage` 실행 시 각 Hook별 커버리지가 명확히 확인된다

### Quality Metrics

- **QM-001**: 테스트 코드가 명확한 네이밍과 구조를 가지며, 다른 개발자가 쉽게 이해할 수 있다
- **QM-002**: 각 테스트가 단일 책임 원칙을 따르며, 하나의 기능만 검증한다
- **QM-003**: Mock 데이터가 실제 프로덕션 데이터 구조를 정확히 반영한다
- **QM-004**: 테스트 실패 시 명확하고 실행 가능한 에러 메시지를 제공한다

## Assumptions

- 프로젝트는 이미 `@testing-library/react-hooks`, Jest, Firebase Test SDK 등 필요한 테스트 라이브러리를 설치했다고 가정합니다.
- 각 Hook의 프로덕션 코드는 이미 작성되어 있으며, 테스트 가능한 구조로 되어 있다고 가정합니다.
- Firebase Emulator 또는 Mock 라이브러리를 사용하여 실제 Firebase 연결 없이 테스트할 수 있다고 가정합니다.
- 개발자는 React Hooks와 비동기 테스트에 대한 기본적인 이해를 가지고 있다고 가정합니다.
- 테스트 환경은 CI/CD 파이프라인에서 자동으로 실행될 수 있도록 구성되어 있다고 가정합니다.
- 70%의 커버리지 목표는 프로젝트 품질 기준에 부합하며, 핵심 로직을 충분히 커버한다고 가정합니다.

## Constraints

- 프로덕션 코드 수정은 최소화되어야 하며, Hook의 공개 인터페이스를 변경할 수 없습니다.
- 테스트는 각 Hook의 기존 동작을 변경하지 않으며, 성능 저하를 초래하지 않아야 합니다.
- 각 Hook의 테스트는 독립적이어야 하며, 다른 테스트나 외부 서비스에 의존하지 않아야 합니다.
- 테스트 실행 시간은 8초 이내로 제한되어 개발 워크플로우를 방해하지 않아야 합니다.
- 모든 테스트는 GitHub Actions 등의 CI 환경에서 재현 가능하게 작성되어야 합니다.

## Dependencies

- Phase 2-2 완료 후 진행 (AuthContext 및 UnifiedDataContext 테스트가 선행되어야 함)
- Firebase Test SDK 및 Firestore Emulator 설정 완료
- 테스트 환경 설정 파일(jest.config.js, setupTests.ts) 준비 완료
- TypeScript 타입 정의 및 strict mode 설정 유지

## Out of Scope

이 기능에서 다루지 않는 항목:

- 통합 테스트 또는 E2E 테스트 (단위 테스트만 대상)
- UI 컴포넌트 테스트 (Hook 테스트에만 집중)
- 성능 벤치마크 테스트 (기능 검증에만 집중)
- 다른 Hook들의 테스트 작성 (명시된 3개 Hook만 대상)
- 프로덕션 코드의 리팩토링 또는 개선
- 테스트 커버리지 도구의 설정 변경
- CI/CD 파이프라인의 수정 또는 개선

## Verification Method

검증은 다음 방법으로 수행됩니다:

1. **테스트 실행**: `npm run test` 명령어로 모든 테스트가 통과하는지 확인
2. **커버리지 확인**: `npm run test:coverage` 명령어로 각 Hook별 커버리지가 70% 이상인지 확인
3. **에러 케이스 검증**: 각 Hook의 테스트 파일에서 최소 5개의 에러 케이스가 포함되었는지 수동 검토
4. **실행 시간 측정**: 테스트 실행 시간이 8초 이내인지 타이머로 확인
5. **독립성 검증**: 각 테스트 파일을 개별적으로 실행하여 독립적으로 동작하는지 확인
6. **비동기 로직 검증**: 각 Hook의 비동기 작업이 테스트로 커버되었는지 코드 리뷰
7. **성능 검증**: 테스트 추가 전후의 프로덕션 코드 실행 시간을 비교하여 성능 저하가 없는지 확인
